## 主要学习内容

* 分治：将一个大问题按一定规律**分解**成多个子问题分别处理，最后再**汇总合并**子问题的处理结果。子问题本身也可以进行这样<br>的操作，进一步分解成子问题的子问题，以此类推，直到不可再分。这样的结构适合使用递归的方式进行处理。代码模板也是<br>在通用递归模板的基础上进行一些特殊处理。代码模板：

  ```java
  // 1.recursion terminator
  // 2.prepare data
  // 3.conquer subproblems
  // 4.process and generate the final result
  // 5.revert the current level states
  ```

* 回溯：采用试错的思想，尝试分步地去解决一个问题。可以理解为在地图上把每一条路的每一个分叉的探了一边，将所有可行<br>的路线都汇总起来。核心是用一个**不断变化**的变量，在尝试各个分叉的过程中，搜索需要的结果。尤其强调了**回退**操作。每一<br>层递归都可以看作是选择了一个分叉，操作完成后，返回上一层，准备尝试其它分支。在尝试其它分支之前，就需要进行**回退**，<br>将在每一层中**变化**的全局变量恢复到之前的状态。在代码中经常可以看到类似这样的操作：

  ```java
  path.addLast(item); // 递归进入下一层前执行操作
  recursion(xx, yy);
  path.removeLast();  // 递归完成后执行相反的操作，恢复原样
  ```

* 联系与区别

  * 联系：
    * 都是是在找问题的**最近重复性**，分治或回溯取决与重复性的构造
    * 都适合采用递归的方式进行处理。
  * 区别：
    * 分治是合并各分支的计算结果，最终得到<font color="red">**一个**</font>汇总值
    * 回溯是要遍历每一个分支，找出所有符合要求的分支，最终得到<font color="red">**一系列**</font>值

## 遇到的难点

* 难度比前两周明显高了很多。分治也好，回溯也罢，思想本身非常朴素，容易理解，但是要应用到代码上时还是经常感觉无从下<br>手。其中的关键都是要<font color="orange">拆分子问题</font>，然后再利用计算机的特性自动运算。但<font color="orange">拆分子问题</font>这件事本身就感觉非常有难度，偶尔灵光<br>一闪能自己想通，更多的时候需要看题解才有头绪，甚至有时候连题解可能都没法完全看懂。更让人难受的是经验好像没法重用，<br>上一道题弄懂了，再来一道类似的题目很可能还是会懵。也许是练的还不够多？

* 涉及到一些比较绕的操作时，复杂度算不清楚。有时理解代码本身的逻辑都很吃力，基本上已经放弃考虑复杂度了，只求通过。
* 在内容本身比较难的情况下，练习量很难跟上。

## 主要收获

* 虽然还是感觉挺难，但终于是直面之前一直望而却步的内容了，对分治和回溯也有了更深入的理解。
* 在做分治和回溯相关题目的时候，又反复练习了递归，感觉更“顺手”了。