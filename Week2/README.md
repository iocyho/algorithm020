# 主要学习内容

1. Hash表
   * Map：根据关键码值(key, value)直接访问，使用Hash函数将关键码值映射到表中的具体位置。当发生Hash碰撞(不同的key映射出的位<br>置相同)时，则采用链表的形式在相同位置保存元素。一般情况下，查询、新增、删除操作的时间复杂度都是O(1)。特殊情况下(大量<br>的元素堆积在同一个位置，导致Hash表退化成链表)时间复杂度退化到O(n)。
   * Set：在Java中是基于HashMap实现的，key为元素的值，value为占位用的Object。
2. 树Tree：单链表中一个元素的尾指针同时指向多个元素时，就形成了树
   * 二叉树：一种特殊的树，每个节点都最多仅有左右两个子节点
   * 二叉搜索树：特殊的二叉树，左子树所有节点的值都小于根节点的值，右子树所有节点的值都大于根节点的值，且左右子树的都符合<br>这一特性。
   * 遍历顺序：基于根节点而言，分为：
     * 前序遍历(根-左-右)
     * 中序遍历(左-根-右)
     * 后序遍历(左-右-根)
3. 堆Heap：用于快速获取最大值<font color="red">或</font>最小值(时间复杂度O(1))，同时针对插入及删除操作也有较好时间复杂度。实现方式有多种，最易于理解的<br>是<font color="orange">二叉堆</font>，底层实现是“数组”。在实际工程中一般直接使用priority queue即可，底层即是通过堆实现。
4. 图Graph：由Vertex(点)和Edge(边)组成
   * Vertex：度(入度-是否可进入该点，出度-是否可从该点前往其它点)、连通性(点与点之间是否可达)
   * Edge：方向(有向或无向)、权重(边长、损耗、etc)。根据方向及权重属性，可以分为“无向无权图”、“有向无权图”、“无向有权图”、“有<br>向有权图”。
   * 数据结构层面，可以通过**邻接矩阵**或**邻接表**来表示图
   * 图的常见算法包括<font color="blue">**DFS**</font>(深度优先搜索)和<font color="blue">**BFS**</font>(广度优先搜索)，<font color="red">需要熟记代码模板</font>。
     * DFS 基于栈，由于递归运行时使用堆栈，因此DFS更适合通过递归来实现
     * BFS 基于队列，因此一般情况下不适合通过递归来实现。eg：从根节点开始遍历树，然后向下搜索最接近根节点的节点。
   * <font color="orange">链表是特殊的树，树是特殊的图</font>

# 遇到的难点

* 代码的复杂度和抽象度相较之前高了不少，个别题目甚至连题解都不太能看懂，暂时把代码强记下来，但是没过多久又忘了。

# 主要收获

* 对树的理解相较之前加深了
* 在遍历树的过程中反复练习了递归和循环的写法，感觉对递归的理解也更进了一步。递归的底层靠栈实现，如果需要把递归改用循环实现，就<br>自己手动维护一个栈。